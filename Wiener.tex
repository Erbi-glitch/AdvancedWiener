\documentclass[12pt,a4paper]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{url}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb,amsthm}

\usepackage[
backend=biber,
bibencoding=utf8,
sorting=none
]{biblatex}
\addbibresource{refs.bib}


\theoremstyle{definition}
\newtheorem{definition}{Определение}
\newtheorem{example}{Пример}
\theoremstyle{plain}
\newtheorem{theorem}{Теорема}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{amsmath,amssymb}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{booktabs}
% ======= Вставьте в преамбулу (если ещё не подключали) =======
\usepackage{amsmath,amssymb}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{decorations.pathmorphing,calc}
\usetikzlibrary{arrows.meta,calc,positioning,graphs,graphs.standard}
\usepackage{amsmath,amssymb,amsthm,mathtools}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,calc,positioning,graphs,graphs.standard}

\newcommand{\W}{\operatorname{W}}
\newcommand{\dist}{\operatorname{dist}}
\newcommand{\V}{V}
\newcommand{\E}{E}
\newcommand{\binomC}[2]{\binom{#1}{#2}}

\theoremstyle{plain}
\newtheorem{proposition}{Утверждение}


\usepackage{graphicx}
\usepackage{subfigure}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}

\lstset{
	language=Python,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	commentstyle=\color{codegreen},
	stringstyle=\color{red},
	numbers=left,
	frame=single
}

\begin{document}
	\thispagestyle{empty}
	
	%\vspace*{0.5cm}
	
	\begin{center}
		\begin{figure}
			\centering
			\includegraphics[width=1\linewidth]{screenshot001}
			\label{fig:screenshot001}
		\end{figure}
		{\large Математическое сочинение:}\\[0.6cm]
		{\LARGE ``Индекс Винера в растущих графах''}\\[0.4cm]
		
		{\Large Чудопалов Денис}\\[0.2cm]
		{\Large ВМК МГУ}\\[1.0cm]
		\vspace*{11cm}
		{\Large Февраль 2026}
	\end{center}
	\newpage
		% Заголовок оглавления и вывод
	\tableofcontents
	\newpage
	
%-----------------------------------------------------Титульник-----------------------------------------------------
	
\section{Введение}
В данной работе рассматривается способы эффективно делать расчёт индекса Винера для растущего графа, в случае присоединения к нему узла или рёбра. Это может быть использванно для многих практических целей и задач имеющих динамическую природу: компьютерные сети, химические соединения, топологией молекул белка.
\subsection{Постановка задачи}
\subsection*{Дано:}
\emph{Неориентированный} граф $G(V, E)$, где $V$ - множество вершин, $E$ - множество ребер.
\subsection*{Задача:}
\begin{itemize}
	\item Дать определение индексу Винера
	\item Найти аналитические решения 
	\item Разобрать удобные частные случаи
	\item Написать программу для вычисления индекса Винера
\end{itemize}
	
	
	
	
	
%-----------------------------------------------------Глава 1-----------------------------------------------------
\newpage
\section{Индекс Винера}

На протяжении всей работы все графы будут неориентированными

\begin{definition}\label{def:distance}
	Пусть $G$ — граф с множеством вершин $V(G)$ и множеством рёбер $E(G)$.
	Расстояние $d_G(u,v)$ между двумя вершинами $u,v\in V(G)$ — это минимальное число рёбер на пути в $G$ между $u$ и $v$.
\end{definition}

\begin{definition}\label{def:wiener}
	Пусть $G$ удовлетворяет определению 1. \emph{Винеровский индекс} $W(G)$ графа $G$ определяется формулой
	\[
	W(G)=\sum_{\{u,v\}\subseteq V(G)} d_G(u,v),
	\]
	а \emph{среднее расстояние} $\mu(G)$ между вершинами графа $G$ — формулой
	\[
	\mu(G)=\frac{W(G)}{\binom{|V(G)|}{2}}.
	\]
\end{definition}

\begin{definition}\label{def:vertex-distance}
	Пусть $G$ удовлетворяет определению 1. \emph{Расстояние вершины} $v$ обозначим через $d_G(v)$ и определим как сумму расстояний между $v$ и всеми остальными вершинами графа $G$:
	\[
	d_G(v)=\sum_{u\in V(G)\setminus\{v\}} d_G(u,v).
	\]
\end{definition}

Таким образом, индекс Винера можно определить немного иначе:
\[
W(G)=\frac12\sum_{v\in V(G)} d_G(v),
\]
где множитель $\tfrac12$ компенсирует тот факт, что каждый путь между $u$ и $v$ учитывается в $d_G(u)$, а также в $d_G(v)$.

\begin{definition}\label{def:diameter}
	Пусть $G$ — граф. \emph{Диаметр} $d(G)$ графа $G$ определяется как
	\[
	d(G)=\min_{\{u,v\}\subseteq V(G)} d_G(u,v).
	\]
\end{definition}

	

\subsection{Пример вычисления индекса Винера}

Рассмотрим граф $T$ на 10 вершинах (рис.~\ref{fig:tree10-compact}):
\[
E(T)=\{(v_1,v_2),(v_2,v_3),(v_3,v_4),(v_4,v_5),(v_5,v_6),
(v_3,v_7),(v_3,v_8),(v_5,v_9),(v_5,v_{10})\}.
\]

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		v/.style={circle, draw, minimum size=7mm, inner sep=0pt},
		every edge/.style={draw, line width=0.7pt}
		]
		\node[v] (v1)  at (0,0)   {$v_1$};
		\node[v] (v2)  at (1.4,0) {$v_2$};
		\node[v] (v3)  at (2.8,0) {$v_3$};
		\node[v] (v4)  at (4.2,0) {$v_4$};
		\node[v] (v5)  at (5.6,0) {$v_5$};
		\node[v] (v6)  at (7.0,0) {$v_6$};
		
		\node[v] (v7)  at (2.8,1.4) {$v_7$};
		\node[v] (v8)  at (2.8,-1.4) {$v_8$};
		
		\node[v] (v9)  at (5.6,1.4) {$v_9$};
		\node[v] (v10) at (5.6,-1.4) {$v_{10}$};
		
		\draw (v1)--(v2)--(v3)--(v4)--(v5)--(v6);
		\draw (v3)--(v7) (v3)--(v8) (v5)--(v9) (v5)--(v10);
	\end{tikzpicture}
	\caption{граф $T$ на 10 вершинах.}
	\label{fig:tree10-compact}
\end{figure}

Индекс Винера считаем по формуле
\[
W(T)=\frac12\sum_{v\in V(T)} d_T(v),\qquad
d_T(v)=\sum_{u\neq v} d_T(u,v).
\]

Для данного графа получаем:
\[
\begin{aligned}
	d_T(v_1)&=31,& d_T(v_2)&=23,& d_T(v_3)&=17,& d_T(v_4)&=19,& d_T(v_5)&=19,\\
	d_T(v_6)&=27,& d_T(v_7)&=25,& d_T(v_8)&=25,& d_T(v_9)&=27,& d_T(v_{10})&=27.
\end{aligned}
\]
Тогда
\[
\sum_{i=1}^{10} d_T(v_i)=240
\quad\Rightarrow\quad
W(T)=\frac12\cdot 240=120.
\]
Среднее расстояние между вершинами:
\[
\mu(T)=\frac{W(T)}{\binom{10}{2}}=\frac{120}{45}=\frac{8}{3}.
\]

%-----------------------------------------------------Глава 1-----------------------------------------------------





%-----------------------------------------------------Глава 2-----------------------------------------------------

\newpage
\section{Аналитические решения}

Первое что приходит в голову после постановки задачи для растущих графов, возможно ли вычислять Индекс Винера с нимиальными затратами? На этот вопрос есть ответ - если индекс можно выразить аналитически, те существует конечная формула. Далее будем рассматривать такие графы.

% ===========================================================
\subsection{Полный граф $K_n$}
Рисунок (пример $K_5$)
\begin{center}
	\begin{tikzpicture}[scale=1.0, every node/.style={circle, draw, inner sep=1.6pt}]
		\node (1) at (90:1.2) {$1$};
		\node (2) at (18:1.2) {$2$};
		\node (3) at (306:1.2) {$3$};
		\node (4) at (234:1.2) {$4$};
		\node (5) at (162:1.2) {$5$};
		\foreach \i/\j in {1/2,1/3,1/4,1/5,2/3,2/4,2/5,3/4,3/5,4/5}{
			\draw (\i) -- (\j);
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
В полном графе $K_n$ любая пара различных вершин соединена ребром, значит
$\dist(x,y)=1$ для всех $x\ne y$. Число неупорядоченных пар равно $\binomC{n}{2}$, поэтому
\[
\boxed{\W(K_n)=\binomC{n}{2}=\frac{n(n-1)}{2}.}
\]

% ===========================================================
\subsection{Путь $P_n$}
Рисунок (пример $P_6$)
\begin{center}
	\begin{tikzpicture}[every node/.style={circle, draw, inner sep=1.6pt}]
		\foreach \i in {1,...,6}{
			\node (v\i) at (\i,0) {$\i$};
		}
		\foreach \i in {1,...,5}{
			\draw (v\i) -- (v\the\numexpr\i+1\relax);
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
Пронумеруем вершины $1,2,\dots,n$ вдоль пути. Тогда
\[
\dist(i,j)=|i-j|.
\]
Для каждого расстояния $d\in\{1,\dots,n-1\}$ число пар вершин на расстоянии $d$ равно $n-d$
(это пары $(i,i+d)$, где $i=1,\dots,n-d$). Тогда
\[
\W(P_n)=\sum_{d=1}^{n-1} d(n-d)
= n\sum_{d=1}^{n-1} d - \sum_{d=1}^{n-1} d^2.
\]
Используем известные суммы:
\[
\sum_{d=1}^{n-1} d=\frac{(n-1)n}{2},\qquad
\sum_{d=1}^{n-1} d^2=\frac{(n-1)n(2n-1)}{6}.
\]
Подставляя, получаем
\[
\W(P_n)=n\cdot\frac{(n-1)n}{2}-\frac{(n-1)n(2n-1)}{6}
=\frac{(n-1)n(n+1)}{6}=\binomC{n+1}{3}.
\]
\[
\boxed{\W(P_n)=\binomC{n+1}{3}=\frac{(n-1)n(n+1)}{6}.}
\]

% ===========================================================
\subsection{Цикл $C_n$}
Рисунок (пример $C_8$)
\begin{center}
	\begin{tikzpicture}[every node/.style={circle, draw, inner sep=1.6pt}]
		\foreach \i in {1,...,8}{
			\node (v\i) at (45*\i:1.5) {$\i$};
		}
		\foreach \i in {1,...,8}{
			\pgfmathtruncatemacro{\j}{mod(\i,8)+1}
			\draw (v\i) -- (v\j);
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
В цикле расстояние между двумя вершинами равно меньшей длине дуги между ними.
Положим $k=\lfloor n/2\rfloor$.

\paragraph{Случай 1: $n=2k+1$ (нечётный).}
Для каждого $d=1,\dots,k$ каждая вершина имеет ровно $2$ вершины на расстоянии $d$,
поэтому число неупорядоченных пар на расстоянии $d$ равно $n$.
Тогда
\[
\W(C_n)=\sum_{d=1}^{k} d\cdot n = n\cdot \frac{k(k+1)}{2}.
\]
Так как $n=2k+1$, то $k(k+1)=\frac{(n^2-1)}{4}$, и
\[
\boxed{\W(C_{2k+1})=\frac{(2k+1)\,k(k+1)}{2}=\frac{n(n^2-1)}{8}.}
\]

\paragraph{Случай 2: $n=2k$ (чётный).}
Для $d=1,\dots,k-1$ число пар на расстоянии $d$ равно $n$.
Для $d=k$ (противоположные вершины) число пар равно $n/2$.
Значит
\[
\W(C_n)=\sum_{d=1}^{k-1} d\cdot n + k\cdot\frac{n}{2}
= n\cdot\frac{(k-1)k}{2}+k\cdot k
= k^3=\frac{n^3}{8}.
\]
\[
\boxed{\W(C_{2k})=k^3=\frac{n^3}{8}.}
\]

% ===========================================================
\subsection{Звезда $S_n=K_{1,n-1}$}
Рисунок (пример $S_7$)
\begin{center}
	\begin{tikzpicture}[every node/.style={circle, draw, inner sep=1.6pt}]
		\node (c) at (0,0) {$c$};
		\foreach \i/\ang in {1/0,2/60,3/120,4/180,5/240,6/300}{
			\node (v\i) at (\ang:1.7) {$\i$};
			\draw (c) -- (v\i);
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
В звезде есть центр $c$ и $n-1$ листьев.
\begin{itemize}
	\item Пар \textit{центр--лист} ровно $n-1$, расстояние $1$.
	\item Пар \textit{лист--лист} ровно $\binomC{n-1}{2}$, расстояние $2$ (через центр).
\end{itemize}
Следовательно,
\[
\W(S_n)=(n-1)\cdot 1 + \binomC{n-1}{2}\cdot 2
=(n-1)+(n-1)(n-2)=(n-1)^2.
\]
\[
\boxed{\W(S_n)=(n-1)^2.}
\]

% ===========================================================
\subsection{Полный двудольный граф $K_{a,b}$}
Рисунок (пример $K_{2,4}$)
\begin{center}
	\begin{tikzpicture}[every node/.style={circle, draw, inner sep=1.6pt}]
		\node (a1) at (0,1) {$a_1$};
		\node (a2) at (0,-1) {$a_2$};
		\foreach \i/\y in {1/1.5,2/0.5,3/-0.5,4/-1.5}{
			\node (b\i) at (3,\y) {$b_\i$};
		}
		\foreach \u in {a1,a2}{
			\foreach \i in {1,2,3,4}{
				\draw (\u) -- (b\i);
			}
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
В $K_{a,b}$ любые две вершины из разных долей имеют расстояние $1$, а любые две вершины из одной доли --- расстояние $2$.
\begin{itemize}
	\item Междольных пар $ab$, вклад $ab$.
	\item Внутри доли размера $a$ пар $\binomC{a}{2}$, вклад $2\binomC{a}{2}$.
	\item Внутри доли размера $b$ пар $\binomC{b}{2}$, вклад $2\binomC{b}{2}$.
\end{itemize}
Итого
\[
\boxed{\W(K_{a,b})=ab + 2\left(\binomC{a}{2}+\binomC{b}{2}\right)
	=ab+a(a-1)+b(b-1).}
\]

% ===========================================================
\subsection{Полный многодольный граф $K_{n_1,\dots,n_k}$}
\subsection*{Полный вывод формулы}
В полном $k$-дольном графе:
\begin{itemize}
	\item если вершины в разных долях, расстояние $1$;
	\item если в одной доле, расстояние $2$ (через любую вершину другой доли).
\end{itemize}
Пусть $n=\sum_{i=1}^k n_i$.
Тогда число пар из разных долей равно $\sum_{i<j} n_i n_j$ (вклад $1$),
а число пар внутри долей равно $\sum_i \binomC{n_i}{2}$ (вклад $2$). Поэтому
\[
\boxed{\W(K_{n_1,\dots,n_k})=\sum_{1\le i<j\le k} n_i n_j \;+\; 2\sum_{i=1}^k \binomC{n_i}{2}.}
\]
Также можно переписать $\sum_{i<j}n_in_j=\binomC{n}{2}-\sum_i\binomC{n_i}{2}$.

% ===========================================================
\subsection{Колесо $W_n$ (цикл на $n-1$ вершинах + центр)}
Рисунок (пример $W_7$)
\begin{center}
	\begin{tikzpicture}[every node/.style={circle, draw, inner sep=1.6pt}]
		\node (h) at (0,0) {$h$};
		\foreach \i in {1,...,6}{
			\node (v\i) at (60*\i:2.0) {$\i$};
		}
		\foreach \i in {1,...,6}{
			\pgfmathtruncatemacro{\j}{mod(\i,6)+1}
			\draw (v\i) -- (v\j);
			\draw (h) -- (v\i);
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
В колесе $W_n$:
\begin{itemize}
	\item Центр $h$ соединён со всеми $n-1$ вершин обода: вклад $n-1$ пар на расстоянии $1$.
	\item На ободе есть $(n-1)$ соседних пар (рёбра цикла), расстояние $1$, вклад $n-1$.
	\item Любые две \emph{несоседние} вершины обода имеют расстояние $2$ (через центр).
	Число всех пар на ободе: $\binomC{n-1}{2}$, значит несоседних пар:
	$\binomC{n-1}{2}-(n-1)$.
\end{itemize}
Итак,
\[
\W(W_n)=(n-1)+(n-1)+2\left(\binomC{n-1}{2}-(n-1)\right)
=2\binomC{n-1}{2}=(n-1)(n-2).
\]
\[
\boxed{\W(W_n)=(n-1)(n-2).}
\]

% ===========================================================
\subsection{Двойная звезда $DS_{a,b}$}

Двойная звезда $DS_{a,b}$: две центральные вершины $u$ и $v$ соединены ребром, к $u$ подвешено $a$ листьев,
к $v$ --- $b$ листьев. Всего вершин $n=a+b+2$. \newline
Рисунок

\begin{center}
	\begin{tikzpicture}[every node/.style={circle, draw, inner sep=1.6pt}]
		\node (u) at (0,0) {$u$};
		\node (v) at (2.2,0) {$v$};
		\draw (u) -- (v);
		\foreach \i/\y in {1/1.0,2/0.0,3/-1.0}{
			\node (ua\i) at (-1.8,\y) {};
			\draw (u) -- (ua\i);
		}
		\foreach \i/\y in {1/0.7,2/-0.7}{
			\node (vb\i) at (4.0,\y) {};
			\draw (v) -- (vb\i);
		}
	\end{tikzpicture}
\end{center}

\subsection*{Вывод формулы}
Считаем вклад по типам пар:
\begin{itemize}
	\item $(u,v)$: одна пара на расстоянии $1$.
	\item $(u,\text{лист у }u)$: $a$ пар на расстоянии $1$; $(v,\text{лист у }v)$: $b$ пар на расстоянии $1$.
	\item Два листа у $u$: $\binomC{a}{2}$ пар на расстоянии $2$; два листа у $v$: $\binomC{b}{2}$ пар на расстоянии $2$.
	\item Лист у $u$ и вершина $v$: $a$ пар на расстоянии $2$; лист у $v$ и вершина $u$: $b$ пар на расстоянии $2$.
	\item Лист у $u$ и лист у $v$: $ab$ пар на расстоянии $3$.
\end{itemize}
Итого
\[
\W(DS_{a,b})
=1+(a+b)+2\left(\binomC{a}{2}+\binomC{b}{2}\right)+2(a+b)+3ab.
\]
Упростим:
\[
2\binomC{a}{2}=a(a-1),\quad 2\binomC{b}{2}=b(b-1),
\]
поэтому
\[
\boxed{\W(DS_{a,b})=1+3(a+b)+a(a-1)+b(b-1)+3ab.}
\]

% ===========================================================
\subsection{Универсальный формула для графов диаметра 2}

Пусть $G$ --- связный граф диаметра $2$, то есть любые две вершины находятся на расстоянии $1$ или $2$.
Пусть $n=|\V(G)|$, $m=|\E(G)|$.
Тогда пар на расстоянии $1$ ровно $m$ (это рёбра), а остальных пар
$\binomC{n}{2}-m$, и они на расстоянии $2$. Следовательно,
\[
\W(G)=1\cdot m+2\left(\binomC{n}{2}-m\right)=2\binomC{n}{2}-m=n(n-1)-m.
\]
\[
\boxed{\text{Если }\operatorname{diam}(G)=2,\ \W(G)=n(n-1)-m.}
\]
Этот формула мгновенно даёт решения для многих классов (включая колёса, многие двудольные графы при $a,b\ge 2$ и т.\,п.).

\subsection{Итог}
Рассмотренные частные случаи делают вычисление индекса Винера элеметраной задачей, при каждом росте графа, нужно всего лишь подставлять значения и получать результат. Однако таких случаев не так много, поэтому далее рассмотрим чуть более общирный класс графов, который может представлять для нас интерес.
%-----------------------------------------------------Глава 2-----------------------------------------------------







%-----------------------------------------------------Глава 3-----------------------------------------------------

\newpage


\section{Случай деревьев}
Особый интерес для нас представляют деревья. Поскольку в дереве путь, а значит и расстояние, между двумя вершинами единственен,
индекс Винера для дерева вычислять существенно проще, чем для произвольного графа.
Далее мы приведём различные формулы для вычисления индекса Винера:
в первой части — прямые формулы, во второй — рекуррентные, которые требуют выполнения
некоторых условий на деревья, но при их выполнении могут значительно упростить вычисления.

\subsection{Прямые формулы для деревьев}

Первая формула, которую мы приведём, является базовой и была получена Х.~Винером в 1947 году.
Если определение индекса Винера акцентирует внимание на сумме расстояний от каждой вершины до всех остальных,
то данная формула подсчитывает, сколько раз в суммарных кратчайших путях используется каждое ребро.

\begin{definition}\label{def:subtrees-edge}
	Пусть $e=(u,v)\in E(T)$ — ребро дерева $T$.
	Поддеревья $T_u$ и $T_v$ определим как связные компоненты графа $T\setminus e$,
	содержащие соответственно вершины $u$ и $v$.
	Числа вершин этих поддеревьев обозначим
	\[
	n_u(e)=|V(T_u)|,\qquad n_v(e)=|V(T_v)|.
	\]
\end{definition}

\begin{theorem}\label{thm:wiener-edge}
	Пусть $T$ — дерево. Тогда
	\begin{equation}\label{eq:wiener-edge}
		W(T)=\sum_{e=(u,v)\in E(T)} n_u(e)\,n_v(e).
	\end{equation}
\end{theorem}

\begin{proof}
	Так как $T$ — дерево, путь между любой вершиной $x\in V(T_u)$ и любой вершиной $y\in V(T_v)$ единственен
	и обязательно содержит ребро $e$.
	Если же вершины $x$ и $y$ выбираются из одной и той же компоненты, то ребро $e$ в путь между ними не входит.
	Следовательно, величина $n_u(e)\,n_v(e)$ в точности равна числу пар вершин, кратчайший путь между которыми проходит через $e$.
	Суммируя $n_u(e)\,n_v(e)$ по всем рёбрам $e\in E(T)$, получаем индекс Винера $W(T)$.
\end{proof}



\begin{definition}\label{def:BuBv_ru}
	Пусть $e=(u,v)\in E(G)$ — ребро графа $G$. Определим множества вершин
	\[
	B_u(e)=\{x\in V(G)\colon d_G(x,u)<d_G(x,v)\},
	\qquad
	B_v(e)=\{y\in V(G)\colon d_G(y,v)<d_G(y,u)\}.
	\]
	Мощности этих множеств обозначим
	\[
	n_u(e)=|B_u(e)|,\qquad n_v(e)=|B_v(e)|.
	\]
\end{definition}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		vtx/.style={circle, draw, inner sep=1.4pt},
		main/.style={line width=0.7pt}
		]
		% магистраль v1--v2--v3--v4--v5--v6
		\node[vtx] (v1) at (0,0) {$v_1$};
		\node[vtx] (v2) at (1.7,0) {$v_2$};
		\node[vtx] (v3) at (3.4,0) {$v_3$};
		\node[vtx] (v4) at (5.1,0) {$v_4$};
		\node[vtx] (v5) at (6.8,0) {$v_5$};
		\node[vtx] (v6) at (8.5,0) {$v_6$};
		
		% ответвления
		\node[vtx] (v7) at (1.7,1.4) {$v_7$};
		\node[vtx] (v8) at (1.7,-1.4) {$v_8$};
		\node[vtx] (v9) at (5.1,1.4) {$v_9$};
		\node[vtx] (v10) at (6.8,1.4) {$v_{10}$};
		
		\draw[main] (v1)--(v2)--(v3)--(v4)--(v5)--(v6);
		\draw[main] (v2)--(v7);
		\draw[main] (v2)--(v8);
		\draw[main] (v4)--(v9);
		\draw[main] (v5)--(v10);
	\end{tikzpicture}
	\caption{Дерево $T$ порядка $10$.}
	\label{fig:mytree10}
\end{figure}

\begin{example}\label{ex:mytree10_wiener}
	Рассмотрим дерево $T$ на рис.~\ref{fig:mytree10}. Поскольку дерево не содержит циклов, каждое ребро является мостом:
	при удалении ребра $e$ дерево распадается на две компоненты размерностей $a$ и $10-a$, и вклад ребра в индекс Винера равен
	$a(10-a)$ (это частный случай формулы $W(T)=\sum_{e} n_u(e)n_v(e)$).
	
	Посчитаем размеры компонент для каждого ребра (достаточно указать меньшую из двух компонент):
	
	\[
	\begin{array}{c|c|c}
		\text{ребро } e & a & a(10-a)\\ \hline
		(v_1,v_2) & 1 & 1\cdot 9=9\\
		(v_2,v_3) & 4 & 4\cdot 6=24\\
		(v_3,v_4) & 5 & 5\cdot 5=25\\
		(v_4,v_5) & 7 & 7\cdot 3=21\\
		(v_5,v_6) & 1 & 1\cdot 9=9\\
		(v_2,v_7) & 1 & 1\cdot 9=9\\
		(v_2,v_8) & 1 & 1\cdot 9=9\\
		(v_4,v_9) & 1 & 1\cdot 9=9\\
		(v_5,v_{10}) & 1 & 1\cdot 9=9
	\end{array}
	\]
	
	Суммируя вклады, получаем
	\[
	W(T)=9+24+25+21+9+9+9+9+9=124.
	\]
\end{example}


\subsection{Итерационные формулы для деревьев}

В этом случае мы будем рассмотривать специальные поддеревья, чтобы получвть индекс Винера всего дерева как комбинацию индексов этих поддеревьев. Например, когда дерево $T$
получается соединением нескольких копий дерева $T'$ в одной вершине $u$, причём каждый раз используется одна и та же вершина
$v'\in V(T')$. Далее будут приведены некоторые рекуррентные формулы.

Первая идея, которая возникает при желании вычислять индекс Винера рекурсивно — взять дерево,
удалить лист и вычислить индекс Винера оставшегося поддерева.

\begin{theorem}\label{thm:leaf-recursion}
	Пусть $T$ — дерево на $n\ge 2$ вершинах, а $v\in V(T)$ — лист дерева $T$.
	Пусть также $(u,v)\in E(T)$ и $T'=T-v$ — подграф дерева $T$, полученный удалением вершины $v$ (и инцидентного ей ребра).
	Тогда
	\[
	W(T)=W(T')+d_{T'}(u)+n-1.
	\]
\end{theorem}

\begin{proof}
	Рассмотрим две вершины $x$ и $y$ дерева $T$.
	Если $v\neq x$ и $v\neq y$, то расстояние между $x$ и $y$ не изменяется после удаления $v$,
	поэтому сумма всех таких расстояний равна $W(T')$.
	
	Если одна из вершин равна $v$, без ограничения общности пусть $x=v$.
	Тогда для любой вершины $y\in V(T')$ имеем
	\[
	d_T(x,y)=d_T(v,y)=d_{T'}(u,y)+1.
	\]
	Суммируя по всем $y\in V(T')$ (таких вершин $n-1$), получаем вклад
	\[
	\sum_{y\in V(T')} d_T(v,y)=\sum_{y\in V(T')} \bigl(d_{T'}(u,y)+1\bigr)=d_{T'}(u)+ (n-1).
	\]
	Складывая с $W(T')$, получаем требуемую формулу.
\end{proof}

\begin{example}\label{ex:Sn-1-plus-leaf}
	Рассмотрим дерево $T$ на $n$ вершинах, полученное из звезды $S_{n-1}$ добавлением ещё одной вершины $v$,
	соединённой с листом $u$ звезды $S_{n-1}$.
	По Теореме~\ref{thm:leaf-recursion} имеем
	\[
	W(T)=W(S_{n-1})+d_{S_{n-1}}(u)+n-1.
	\]
	Для звезды $S_{n-1}$ известно, что
	\[
	W(S_{n-1})=(n-2)^2,
	\]
	а для листа $u$:
	расстояние до центра равно $1$, а до остальных $n-3$ листьев равно $2$, поэтому
	\[
	d_{S_{n-1}}(u)=1+2(n-3)=2n-5.
	\]
	Следовательно,
	\[
	W(T)=(n-2)^2+(2n-5)+n-1=n^2-n-2.
	\]
\end{example}

Так как в доказательстве того, что $T$ является деревом, использовался лишь подсчёт числа пар вершин $\{v,y\}$,
очевидно, что Теорему~\ref{thm:leaf-recursion} можно обобщить и на связные графы.
Поэтому отдельно запишем обобщенную теорему.

\begin{theorem}\label{thm:leaf-connected-graph}
	Пусть $G$ — связный граф, а $v\in V(G)$ — лист (вершина степени $1$).
	Пусть также $(v,u)\in E(G)$ и $G' = G - v$ — подграф графа $G$, полученный удалением вершины $v$
	(и инцидентного ей ребра). Тогда
	\[
	W(G)=W(G')+d_{G'}(u)+|V(G')|.
	\]
\end{theorem}


\begin{theorem}\label{thm:decomposition}
	Пусть $T$ — дерево порядка $n\ge 2$, полученное следующим образом:
	берём вершину $v$ и поддеревья $T_1,\dots,T_m$, попарно не пересекающиеся по вершинам, и соединяем $v$ с вершиной
	$u_i\in V(T_i)$ для каждого $i=1,\dots,m$.
	Тогда
	\begin{equation}\label{eq:decomposition}
		W(T)=\sum_{i=1}^{m}\Bigl[\,W(T_i)+(n-|V(T_i)|)\,d_{T_i}(u_i)-|V(T_i)|^2\,\Bigr]+n(n-1).
	\end{equation}
\end{theorem}

\begin{proof}
	Зафиксируем $i$ и рассмотрим пары вершин $(x,y)$, где $x\in V(T_i)$.
	
	\smallskip
	\noindent\textbf{Случай 1: $y\in V(T_i)$.}
	Тогда $d_T(x,y)=d_{T_i}(x,y)$, а сумма по всем таким парам равна $W(T_i)$.
	
	\smallskip
	\noindent\textbf{Случай 2: $y\in V(T_j)$, $j\neq i$, или $y=v$.}
	Пусть $y\in V(T_j)$, $j\neq i$ (случай $y=v$ получается аналогично и включится в итоговую формулу).
	Единственный путь в дереве проходит через вершины $u_i$, затем $v$, затем $u_j$, поэтому
	\[
	d_T(x,y)=d_{T_i}(x,u_i)+d_T(u_i,v)+d_T(v,u_j)+d_{T_j}(u_j,y).
	\]
	Поскольку $u_i$ соединена с $v$ одним ребром, имеем $d_T(u_i,v)=1$ и $d_T(v,u_j)=1$, откуда
	\[
	d_T(x,y)=d_{T_i}(x,u_i)+2+d_{T_j}(u_j,y).
	\]
	
	Суммируя по всем $y\notin V(T_i)$, заметим, что для фиксированного $x\in V(T_i)$ величина
	$d_{T_i}(x,u_i)$ повторяется ровно $n-|V(T_i)|$ раз, поэтому
	\[
	\sum_{y\notin V(T_i)} d_T(x,y)=(n-|V(T_i)|)\,d_{T_i}(x,u_i)+\sum_{y\notin V(T_i)}\bigl(2+d_{\text{(в своей компоненте)}}\bigr).
	\]
	После суммирования по всем $x\in V(T_i)$ и приведения подобных членов получаем (в стандартной записи через
	$d_{T_i}(u_i)=\sum_{x\in V(T_i)} d_{T_i}(x,u_i)$) цепочку преобразований:
	\[
	\begin{aligned}
		W(T)
		&=\sum_{i=1}^{m}\Biggl[\,W(T_i)+\frac12\sum_{x\in V(T_i)}\sum_{\substack{y\in V(T)\\ y\notin V(T_i)}}
		\bigl(d_{T_i}(x,u_i)+d_T(u_i,v)\bigr)\Biggr]\\
		&=\sum_{i=1}^{m}\Biggl[\,W(T_i)+\sum_{x\in V(T_i)}\bigl(d_{T_i}(x,u_i)+1\bigr)\,(n-|V(T_i)|)\Biggr]\\
		&=\sum_{i=1}^{m}\Bigl[\,W(T_i)+(n-|V(T_i)|)\bigl(d_{T_i}(u_i)+|V(T_i)|\bigr)\Bigr]\\
		&=\sum_{i=1}^{m}\Bigl[\,W(T_i)+(n-|V(T_i)|)\,d_{T_i}(u_i)-|V(T_i)|^2\Bigr]
		\;+\;n\sum_{i=1}^{m}|V(T_i)|.
	\end{aligned}
	\]
	Так как вершины $T_1,\dots,T_m$ вместе дают все вершины дерева, кроме $v$, имеем
	\[
	\sum_{i=1}^{m}|V(T_i)|=n-1,
	\]
	и потому последний член равен $n(n-1)$. Получаем формулу~\eqref{eq:decomposition}.
\end{proof}


\begin{example}\label{ex:comet}
	Рассмотрим дерево $T$ на $n$ вершинах, полученное следующим образом:
	берём путь $P_{l+1}$ и к одному из его концов $v$ присоединяем ещё $n-l-1$ висячих вершин
	(то есть добавляем $n-l-1$ листьев, смежных с $v$).
	Покажем, как вычислить $W(T)$ с помощью Теоремы~\ref{thm:decomposition}.
	
	В качестве разделяющей вершины возьмём вершину $v$.
	Тогда поддеревья $T_i$ имеют вид:
	\begin{itemize}
		\item $n-l-1$ поддеревьев, состоящих из одной вершины (лист), для каждого из них $|V(T_i)|=1$, $W(T_i)=0$, $d_{T_i}(u_i)=0$;
		\item одно поддерево, являющееся путём на $l$ вершинах (это $P_{l}$), причём $u$ — его конец, смежный с $v$.
	\end{itemize}
	
	\noindent
	Для одиночной вершины вклад в сумму из \eqref{eq:decomposition} равен
	\[
	W(T_i)+(n-|V(T_i)|)d_{T_i}(u_i)-|V(T_i)|^2
	=0+(n-1)\cdot 0-1^2=-1,
	\]
	поэтому суммарный вклад всех $n-l-1$ листьев равен $-(n-l-1)$.
	
	\medskip
	\noindent
	Для пути $P_l$ используем известные формулы:
	\[
	W(P_l)=\binom{l+1}{3},\qquad
	d_{P_l}(u)=\sum_{k=0}^{l-1}k=\binom{l}{2},\qquad |V(P_l)|=l.
	\]
	Тогда вклад этого поддерева в \eqref{eq:decomposition} равен
	\[
	W(P_l)+(n-l)\,d_{P_l}(u)-l^2
	=\binom{l+1}{3}+(n-l)\binom{l}{2}-l^2.
	\]
	
	С учётом последнего слагаемого $n(n-1)$ из \eqref{eq:decomposition} получаем
	\[
	\begin{aligned}
		W(T)
		&=\Bigl(\binom{l+1}{3}+(n-l)\binom{l}{2}-l^2\Bigr)\;-\;(n-l-1)\;+\;n(n-1)\\
		&=\binom{l+1}{3}+(n-l)\binom{l}{2}-(n-l-1)-l^2+n(n-1).
	\end{aligned}
	\]
	Упрощая выражение, получаем компактную форму:
	\[
	W(T)=\binom{l}{3}+(n-l-1)\binom{l}{2}+(n-1)^2.
	\]
\end{example}

% ====== (опционально) Рисунок к примеру: "путь + веер листьев" ======
\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		scale=1,
		every node/.style={font=\normalsize},
		main/.style={line width=0.8pt},
		wavy/.style={decorate, decoration={snake, amplitude=1.2mm, segment length=4mm}}
		]
		
		% координаты верхних вершин
		\coordinate (u) at (0,1.8);
		\coordinate (v) at (4.2,1.8);
		
		% вершины u и v
		\node[circle, fill=black, inner sep=1.4pt, label=above:$u$] (U) at (u) {};
		\node[circle, fill=black, inner sep=1.4pt, label=above:$v$] (V) at (v) {};
		
		% "треугольники" Tu и Tv
		\coordinate (A1) at (-1.2,-0.6);
		\coordinate (B1) at (1.2,-0.6);
		\draw[main] (U) -- (A1) -- (B1) -- (U);
		\node at (0,0.35) {$T_u$};
		
		\coordinate (A2) at (3.0,-0.6);
		\coordinate (B2) at (5.4,-0.6);
		\draw[main] (V) -- (A2) -- (B2) -- (V);
		\node at (4.2,0.35) {$T_v$};
		
		% волнистая "перемычка" (путь из k новых вершин)
		\draw[wavy, main] (U) -- (V);
		
	\end{tikzpicture}
	\caption{Деревья $T_u$ и $T_v$, соединённые путём из $k$ новых вершин.}
	\label{fig:TuTv_path_k}
\end{figure}
\subsection{Итог}
В этой главе мы показали основные прямые и итерационные методы вычисления индекса Винера в деревьях. С помошью итерационных методов вычислять индекс Винера в растущих деревьях можно с помощью нехитрых формул, что минимизирует процесс вычислений и делает их максимально быстрыми.


%-----------------------------------------------------Глава 3-----------------------------------------------------

%-----------------------------------------------------Глава 4-----------------------------------------------------
\newpage


\section{Теоретические основы итерационного вычисления индекса Винера на растущем графе}

Была поставлена задача реализовать конкретную процедуру по вычислению индексов Винера для растущих графов эффективнее, чем в готовом пакете networkX. В пакете существует только одна функция вычисления индекса Винера, которая реализована для статичного графа. Поэтому вычисления с помощью готовой функции будут крайне не эффективными. Следовательно логично реализовать ее самим. \newline
Для начала надо понять как это можно сделать для случая \texttt{leaf} и \texttt{edge}.

\subsection{Добавление \texttt{leaf}}
Рассмотрим операцию роста \texttt{leaf}: к графу $G$ добавляется новая вершина $x\notin V$
и ровно одно ребро $(x,p)$, где $p\in V$ --- уже существующая вершина. Обозначим новый граф через
\[
G' = G + \{x\} + \{(x,p)\}.
\]

Добавление листа не изменяет расстояния между старыми вершинами, так как возникнуть новых более коротких маршрутов не может.
Следовательно, изменения индекса Винера возникают только за счёт новых пар $(x,v)$, $v\in V$:
\begin{equation}
	W(G') = W(G) + \sum_{v\in V} d_{G'}(x,v).
	\label{eq:wiener_leaf_update}
\end{equation}

Так как граф невзвешенный, величина $\sum_{v\in V} d_{G'}(x,v)$ вычисляется одним обходом в ширину (BFS)
из источника $x$ за время $O(|V|+|E|)$ на текущем графе.

\subsection{Добавление \texttt{edge}}
Рассмотрим операцию роста \texttt{edge}: добавляется ребро между двумя уже существующими вершинами
$a,b\in V$:
\[
G' = G + \{(a,b)\}.
\]
Добавление ребра может сократить кратчайшие пути для большого числа пар вершин.
Поэтому точное итерационное обновление $W(G)$ при вставках рёбер неочевидно;
поэтому потребуется точный пересчёт $W(G')$.

\subsection{Общая схема модулей}
Реализация разделена на два файла:
\begin{itemize}
	\item \texttt{wiener.py} --- класс \texttt{WienerGrowingUnweighted}, вычисление индекса Винера
	при росте графа;
	\item \texttt{main.py} --- загрузка датасета, построение графа, рандомизированное выполнение операций
	роста, измерение времени и сохранение графика.
\end{itemize}



\subsection{Программная реализация на python}

Реализуем Класс и соотвествующие ему функции. \newline
\newpage

\begin{lstlisting}
class WienerGrowingUnweighted:

	
	def __init__(self) -> None:
		self.G = nx.Graph()
		self.W = 0.0
		
	def add_initial_node(self, u: Any) -> None:
		self.G.add_node(u)
		self.W = 0.0
	
	def add_leaf(self, u: Any, attach_to: Any) -> float:
		self.G.add_node(u)
		self.G.add_edge(u, attach_to)		
		dist = nx.single_source_shortest_path_length(self.G, u)
		self.W += sum(dist.values())
		return self.W
	
	def add_edge(self, a: Any, b: Any) -> float:
		if a == b:
			return self.W
			
		self.G.add_edge(a, b)
		self.W = float(nx.wiener_index(self.G))
		return self.W

\end{lstlisting}


\subsection{Устройство кода генерации растущего графа}


Далее часть \texttt{main.py}, отвечающая за генерацию \emph{растущего графа}.

На вход подаётся файл со списком рёбер (формат \emph{edgelist}). Функция загрузки читает файл в байтовом режиме
(без декодирования в UTF-8), формируя неориентированный граф $G$ (объект \texttt{networkx.Graph}).

Если исходный граф несвязен, выбирается крупнейшая связная компонента $H$:
\[
H \;=\; \text{LargestConnectedComponent}(G).
\]
Дальнейший рост происходит так, чтобы текущий граф на каждом шаге оставался связным.
\newline
Функция \texttt{bfs\_tree\_edges\_sorted(H, root)} строит BFS-остов из вершины $root$.
\newline
Результатом является список рёбер BFS-дерева в порядке открытия:
\[
T = \bigl( (p_1,c_1), (p_2,c_2), \dots, (p_{n-1},c_{n-1}) \bigr),
\]
где каждое ребро $(p_i,c_i)$ означает: вершина $c_i$ впервые обнаружена из $p_i$.

На основе $T$ строится отображение
\[
\text{children\_by\_parent}[p] = \{\,c:\ (p,c)\in T\,\},
\]
которое в коде реализовано как словарь \texttt{parent $\to$ deque(children)}.
Эта структура позволяет добавлять новые вершины только тогда, когда их родитель уже присутствует в текущем графе.

\subsubsection{Дополнительные рёбра (не входящие в BFS-остов)}
Все рёбра исходного графа $H$, не входящие в BFS-остов, образуют множество \emph{дополнительных рёбер}:
\[
E_{\mathrm{extra}} \;=\; E(H)\setminus E(T).
\]
В коде это формируется в виде списка \texttt{extra\_edges} (с нормализацией порядка концов ребра и сортировкой),
чтобы вход бы определен.


\subsubsection{Почему все выполняется корректно}
Для корректного роста вводится множество активных вершин $A$ --- вершин, которые уже добавлены
в текущий граф роста. В начале:
\[
A=\{root\}.
\]

Операция \texttt{leaf}$(c,p)$ выполнима только если $p\in A$.
Операция \texttt{edge}$(u,v)$ выполнима только если $u\in A$ и $v\in A$.

Чтобы эффективно находить \texttt{edge}-операции, которые становятся выполнимыми после добавления новой вершины,
строится индекс инцидентности:
\[
\text{incident}[x] = \{\, i \mid \text{extra\_edges}[i] \text{ инцидентно вершине } x \,\}.
\]
После добавления вершины $x$ активируются все рёбра $(x,y)$, для которых $y\in A$.
В коде это множество хранится как \texttt{eligible\_edges} (индексы в \texttt{extra\_edges}).

\subsubsection{Рандомизированное чередование \texttt{leaf}/\texttt{edge}}
Функция \texttt{make\_randomized\_ops(...)} строит последовательность шагов роста (до \texttt{max\_ops} шагов),
случайно чередуя \texttt{leaf} и \texttt{edge} при соблюдении всех условий.

Если доступны оба типа операций, то \texttt{edge} выбирается с вероятностью $p_{\mathrm{edge}}$,
иначе выбирается \texttt{leaf}. Если доступен только один тип, выбирается он.

\paragraph{Роль seed.}
Для воспроизводимости используется генератор \texttt{random.Random(seed)}.
При фиксированном \texttt{seed} последовательность случайных выборов повторяется, то есть траектория роста
(порядок добавления вершин и рёбер) будет одинаковой при каждом запуске.

\subsubsection{Итог}
Итоговая логика генерации роста:
\begin{enumerate}
	\item загрузить граф $G$ и выделить крупнейшую компоненту $H$;
	\item выбрать корень $root$;
	\item построить BFS-остов $T$ и структуру \texttt{children\_by\_parent};
	\item построить список дополнительных рёбер \texttt{extra\_edges};
	\item начиная с $A=\{root\}$, итеративно выполнять шаги:
	\begin{itemize}
		\item \texttt{leaf}: добавить новую вершину из \texttt{children\_by\_parent} и обновить $A$;
		\item после добавления вершины активировать допустимые дополнительные рёбра в \texttt{eligible\_edges};
		\item \texttt{edge}: выбрать одно допустимое ребро из \texttt{eligible\_edges} и добавить его;
	\end{itemize}
	пока не выполнено \texttt{max\_ops} шагов или пока операции не исчерпаны.
\end{enumerate}

Такая конструкция обеспечивает, что на каждом шаге строится корректный промежуточный граф
(все рёбра добавляются только между уже существующими вершинами), при этом порядок роста
может быть случайно перемешан, но остаётся воспроизводимым при фиксированном seed.




%-----------------------------------------------------Глава 4-----------------------------------------------------


%-----------------------------------------------------Глава 5-----------------------------------------------------
\newpage
\section{Резульаты}
Написанная мой программа была протестированна на трех датасетах (), взятых из Stanford Large Network Dataset Collection(SNAP).
Результат оказался предсказуемым, времени потребовалась почти в 2 раза меньше, чем у стандартной функции networkX. Даже чисто интуитивно можно заметить, что ветвь синяя линия напоминает ветвь параболы (функция $f(x) = x^2$), а оранжевая $f(x) = $$x^2 \over 2$
\subsection*{Графики}

% TODO: \usepackage{graphicx} required
\begin{figure}[!htbp]
	\begin{minipage}[!htbp]{0.45\linewidth}
		\center{\includegraphics[width=1\linewidth]{program/ca-HepPh500}}
		
	\end{minipage}
	\hfill
	\begin{minipage}[!htbp]{0.45\linewidth}
		\center{\includegraphics[width=1\linewidth]{program/ca-HepPh2000}}

	\end{minipage}
	\caption{Сеть сотрудничества Arxiv в области физики высоких энергий}
\end{figure}

% TODO: \usepackage{graphicx} required
\begin{figure}[!htbp]
	\begin{minipage}[!htbp]{0.45\linewidth}
		\center{\includegraphics[width=1\linewidth]{program/email-Enron500}}
	\end{minipage}
	\hfill
	\begin{minipage}[!htbp]{0.45\linewidth}
		\center{\includegraphics[width=1\linewidth]{program/email-Enron2000}}
	\end{minipage}
	\caption{Сеть электронной переписки компании Enron}
\end{figure}
\clearpage
% TODO: \usepackage{graphicx} required
\begin{figure}[!htbp]
	\begin{minipage}[!htbp]{0.45\linewidth}
		\center{\includegraphics[width=1\linewidth]{program/facebook_time500}}
	\end{minipage}
	\hfill
	\begin{minipage}[!htbp]{0.45\linewidth}
		\center{\includegraphics[width=1\linewidth]{program/facebook_time2000}}
	\end{minipage}
	\caption{Социальные круги из Facebook (анонимизированные)}
\end{figure}


%-----------------------------------------------------Глава 5-----------------------------------------------------
%-----------------------------------------------------Глава 6-----------------------------------------------------
\section{Вывод}
В данной работе я рассмотрел различные способы вычисления индекса Винера для растущего графа. Были предложены аналитические решения некоторых случаев роста графа. Было проанализирован частный случай дерева и усовершенствована функция вычисления индекса Винера для растущих графов из библиотеки networkX и предоставлены графики скорости вычислений.
\section{Дальнейшие направления для развития}
Индекс Винера применяется во многих сферах, поэтому было бы логично для будующих исследований испкать новые способы эффективного вычисления, а так же расширять и обобщать рекуррентные формулы на более широкий класс графов, не ограничиваясь деревьями.\newline
Так же интерес могут представлять исследование погрешностей при приближённом обновлении индекса Винера — оценка, насколько точно можно обновлять $W(G)$ на больших графах, жертвуя частью точности ради выигрыша в скорости.\newline
Наконец, полученные алгоритмы и подходы можно применять к реальным задачам: от анализа сетей различной природы (социальных, транспортных, коммуникационных) до исследования молекулярных структур.
\section{Список используемой литературы}
\nocite{*}
\printbibliography[heading=none]
%-----------------------------------------------------Глава 6-----------------------------------------------------
\end{document}
